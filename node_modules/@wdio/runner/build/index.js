"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _fs = _interopRequireDefault(require("fs"));

var _path = _interopRequireDefault(require("path"));

var _util = _interopRequireDefault(require("util"));

var _events = _interopRequireDefault(require("events"));

var _logger = _interopRequireDefault(require("@wdio/logger"));

var _utils = require("@wdio/utils");

var _config = require("@wdio/config");

var _reporter = _interopRequireDefault(require("./reporter"));

var _utils2 = require("./utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const log = (0, _logger.default)('@wdio/runner');

class Runner extends _events.default {
  constructor() {
    super();
    this.configParser = new _config.ConfigParser();
    this.sigintWasCalled = false;
  }

  async run({
    cid,
    argv,
    specs,
    caps,
    configFile,
    server,
    retries
  }) {
    var _context;

    this.cid = cid;
    this.specs = specs;
    this.caps = caps;

    try {
      this.configParser.addConfigFile(configFile);
    } catch (e) {
      return this._shutdown(1);
    }

    this.configParser.merge(argv);
    this.configParser.merge(server);
    this.configParser.filterWorkerServices();
    this.config = this.configParser.getConfig();

    _logger.default.setLogLevelsConfig(this.config.logLevels, this.config.logLevel);

    this.isMultiremote = !Array.isArray(this.configParser.getCapabilities());
    (0, _utils.initialiseServices)(this.config, caps).map((_context = this.configParser).addService.bind(_context));
    await (0, _utils2.runHook)('beforeSession', this.config, this.caps, this.specs);
    const browser = await this._initSession(this.config, this.caps);
    this.reporter = new _reporter.default(this.config, this.cid, browser.capabilities);
    this.inWatchMode = Boolean(this.config.watch);

    if (!browser) {
      return this._shutdown(1);
    }

    const isMultiremote = Boolean(browser.isMultiremote);

    if (this.sigintWasCalled) {
      log.info('SIGINT signal detected while starting session, shutting down...');
      await this.endSession();
      return this._shutdown(0);
    }

    this.framework = (0, _utils.initialisePlugin)(this.config.framework, 'framework');
    const instances = (0, _utils2.getInstancesData)(browser, isMultiremote);
    this.reporter.emit('runner:start', {
      cid,
      specs,
      config: this.config,
      isMultiremote,
      sessionId: browser.sessionId,
      capabilities: isMultiremote ? browser.instances.reduce((caps, browserName) => {
        caps[browserName] = browser[browserName].capabilities;
        return caps;
      }, {}) : browser.capabilities,
      retry: (this.config.specFileRetries || 0) - (retries || 0)
    });
    const {
      protocol,
      hostname,
      port,
      path,
      queryParams
    } = browser.options;
    const {
      isW3C,
      sessionId
    } = browser;
    process.send({
      origin: 'worker',
      name: 'sessionStarted',
      content: {
        sessionId,
        isW3C,
        protocol,
        hostname,
        port,
        path,
        queryParams,
        isMultiremote,
        instances
      }
    });
    let failures = 0;

    try {
      failures = await this.framework.run(cid, this.config, specs, caps, this.reporter);
      await this._fetchDriverLogs(this.config, caps.excludeDriverLogs);
    } catch (e) {
      log.error(e);
      this.emit('error', e);
      failures = 1;
    }

    if (!argv.watch) {
      await this.endSession();
    }

    this.reporter.emit('runner:end', {
      failures,
      cid: this.cid,
      retries
    });
    return this._shutdown(failures);
  }

  async _initSession(config, caps) {
    let browser = null;

    try {
      browser = global.browser = global.driver = await (0, _utils2.initialiseInstance)(config, caps, this.isMultiremote);
    } catch (e) {
      log.error(e);
      this.emit('error', e);
      return browser;
    }

    browser.config = config;

    global.$ = selector => browser.$(selector);

    global.$$ = selector => browser.$$(selector);

    browser.on('command', command => this.reporter.emit('client:beforeCommand', Object.assign(command, {
      sessionId: browser.sessionId
    })));
    browser.on('result', result => this.reporter.emit('client:afterCommand', Object.assign(result, {
      sessionId: browser.sessionId
    })));
    return browser;
  }

  async _fetchDriverLogs(config, excludeDriverLogs) {
    if (!config.outputDir || !global.browser.sessionId || typeof global.browser.getLogs === 'undefined') {
      return;
    }

    global._HAS_FIBER_CONTEXT = true;
    let logTypes;

    try {
      logTypes = await global.browser.getLogTypes();
    } catch (errIgnored) {
      return;
    }

    logTypes = (0, _utils2.filterLogTypes)(excludeDriverLogs, logTypes);
    log.debug(`Fetching logs for ${logTypes.join(', ')}`);
    return Promise.all(logTypes.map(async logType => {
      let logs;

      try {
        logs = await global.browser.getLogs(logType);
      } catch (e) {
        return log.warn(`Couldn't fetch logs for ${logType}: ${e.message}`);
      }

      if (logs.length === 0) {
        return;
      }

      const stringLogs = logs.map(log => JSON.stringify(log)).join('\n');
      return _util.default.promisify(_fs.default.writeFile)(_path.default.join(config.outputDir, `wdio-${this.cid}-${logType}.log`), stringLogs, 'utf-8');
    }));
  }

  async _shutdown(failures) {
    try {
      await this.reporter.waitForSync();
    } catch (e) {
      log.error(e);
    }

    this.emit('exit', failures === 0 ? 0 : 1);
    return failures;
  }

  async endSession(payload) {
    if (!global.browser && payload && payload.argv && payload.argv.watch) {
      if (payload.argv.isMultiremote) {
        this.isMultiremote = true;
        global.browser = await (0, _utils2.attachToMultiremote)(payload.argv.instances, payload.argv.caps);
      } else {
        global.browser = await (0, _utils2.initialiseInstance)(payload.argv.config, payload.argv.caps, false);
      }
    }

    const hasSessionId = global.browser && (this.isMultiremote ? !global.browser.instances.some(i => global.browser[i] && !global.browser[i].sessionId) : global.browser.sessionId);

    if (!payload && !hasSessionId) {
      return;
    }

    if (payload && !hasSessionId) {
      await new Promise(resolve => setTimeout(resolve, 250));
      return this.endSession(payload);
    }

    let capabilities = global.browser.capabilities || {};

    if (this.isMultiremote) {
      global.browser.instances.forEach(i => {
        capabilities[i] = global.browser[i].capabilities;
      });
    }

    await global.browser.deleteSession();

    if (this.isMultiremote) {
      global.browser.instances.forEach(i => {
        delete global.browser[i].sessionId;
      });
    } else {
      delete global.browser.sessionId;
    }

    await (0, _utils2.runHook)('afterSession', global.browser.config, capabilities, this.specs);

    if (payload) {
      return this._shutdown();
    }
  }

}

exports.default = Runner;